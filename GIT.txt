Lesson2:
https://geekbrains.ru/records/943#comment-125325
Спасибо, все очень доступно ! Список команд из урока (микро-конспект) 
clone - создание локальной копии git-репозитория (выполняется единоразово); 
commit - сохранить изменения в локальном репозитории; 
push - отправляет изменения на удаленный git-репозиторий; 
pull - скачка последней версии с удаленного git-репозитория;

Lesson3:
https://geekbrains.ru/records/944#comment-125330
микро-конспект discard - удалить все неотправленные в локальный репозиторий изменения 
revert - откатить существующие локальные комиты 
hard reset - удалить несколько последних комитов в локальный репозиторий

Lesson4:
Микро-конспект  Порядок работы при ветвлении:  
1. Создаем "новую ветку", пишем код. 
2. Тестируем "новую ветку". 
3. Мерджим "мастер" в "новую ветку". 
4. Тестируем как работает "новая ветка" с "мастером". 
5. Мерджим "новую ветку" в "мастер". 
6. Удаляем "новую ветку" т.к. она больше не нужна.


Lesson5:
Разрешение конфликтов (это когда файл изменяется одновременно в обоих ветках, и при слиянии необходимо вручную определить какие изменения нужны.)


Lesson6:
Мини-конспект. 
Ошибка 1. Боязнь создания новых веток. 
Правильно - создавать новые ветки для добавления в программу новых функций, по завершению их разработки Merge новую функцию в основную программу. 
Ошибка 2. Добавлять в репозиторий "бинарники" (.exe-файлы, откомпилированную программу). 
Правильно - пользоваться функцией Ignore (то есть не комитить выбранные файлы/папки). 
Нажать Ignore нужных файлов и выполнить Commit для файла .gitignore.

Lesson7:
Микро-конспект  1. Для каждого изменения делать новую ветку, которую по завершению сливать в мастер. 
2. Не нужно комитить скомпилированные файлы (использовать команду Ignore). 
3. При создании "новой ветки" не нужно удалять файлы "мастера" перенесенные в "новую ветку", т.к. при последующем слиянии "новой ветки" с "мастером" эти файлы будут удалены из "мастера". 
4. Избегать больших коммитов. Для разных логических изменений (разных файлов) - разные комиты.  
+ В коментарии к мелкому коммиту легче описать изменения 
+ По коммитам можно откатить изменения 
5. Использовать Cherry-pick - позволяет подтянуть только тот комит (Log) в другую ветку, что нужен не сливая ветки полностью. Супер фича !


Lesson8: Console GIT
https://geekbrains.ru/records/949#comment-129696
git clone - скачивание репозитория 
git status - просмотр текущих изменений 
git add - добавить файл в локальный репозиторий 
git commit - коммит в локальный репозиторий 
git push - коммит в удаленный репозиторий

https://geekbrains.ru/records/949#comment-126999
Мини-конспект. git clone - Перейти в нужную директорию (командами cd и другими, если нужно) и выполнить git clone https://github.com/{ваш путь}.git при этом создастся субдиректория по названию репозитория на гитхабе git status - показывает нужно ли что-то коммитить (точнее есть ли изменённые файлы, в т.ч. в индексе и не в индексе) git add - добавляет указанный файл в индекс (staging area) для последующего коммита git commit - коммитит файлы в индексе 
git commit -a - коммитит всё, но новые файлы только если в индексе, а изменённые и не в индексе 
git commit filename - коммитит указанный файл 
git commit -m "commit message" - сразу написать commit message, иначе откроет окно ввода коммит-сообщения, которым плохо понятно как пользоваться и из которого хрен разберёшься как выходить (оказалось нажать ESC, ввести :wq и нажать Enter) В чём разница делать add потом commit или сразу commit нужно ещё изучать дополнительно. Похоже лучше всегда делать add перед коммитом. git log - показывает лог коммитов с коммит-сообщениями Полезные ресурсы: git-scm.com

Накопал сам в гугле:
чтобы гит-консоль не спрашивал логин/пароль каждый раз:
git config --global credential.helper store  --пароль в открытом виде неограниченное время
git config --global credential.helper cache -- пароль кешируется по умолчанию 15 минут



